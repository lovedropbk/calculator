package campaigns

import (
	"errors"
	"fmt"
	"math"
	"sort"

	"github.com/financial-calculator/engines/types"
	"github.com/shopspring/decimal"
)

// Engine handles campaign application and stacking
type Engine struct {
	parameterSet types.ParameterSet
	// commission provides percent lookup by product for Dealer Commission auto mode.
	// It matches the minimal method of calculator.CommissionLookup without importing that package to avoid module cycles.
	commission commissionLookup
}

// NewEngine creates a new campaign engine
func NewEngine(params types.ParameterSet) *Engine {
	return &Engine{
		parameterSet: params,
	}
}

// SetCommissionLookup injects a CommissionLookup provider used to resolve Dealer Commission in auto mode.
// The interface matches calculator.CommissionLookup (method-only) to avoid importing calculator and creating a module cycle.
func (e *Engine) SetCommissionLookup(l commissionLookup) *Engine {
	e.commission = l
	return e
}

// ApplyCampaigns applies campaigns in the correct stacking order
func (e *Engine) ApplyCampaigns(deal types.Deal, campaigns []types.Campaign) (*CampaignResult, error) {
	result := &CampaignResult{
		OriginalDeal:    deal,
		TransformedDeal: deal,
		AuditEntries:    []types.CampaignAuditEntry{},
		T0Flows:         []types.Cashflow{},
	}

	// Sort campaigns by stacking order
	sortedCampaigns := e.sortCampaigns(campaigns)

	// Apply each campaign in order
	for _, campaign := range sortedCampaigns {
		auditEntry, err := e.applySingleCampaign(&result.TransformedDeal, campaign)
		if err != nil {
			// Log error but continue with other campaigns
			auditEntry = types.CampaignAuditEntry{
				CampaignID:   campaign.ID,
				CampaignType: campaign.Type,
				Applied:      false,
				Description:  fmt.Sprintf("Failed to apply: %v", err),
			}
		}

		result.AuditEntries = append(result.AuditEntries, auditEntry)

		// Add any T0 flows generated by the campaign
		if auditEntry.T0Flow.GreaterThan(decimal.Zero) {
			t0Flow := types.Cashflow{
				Date:      deal.PayoutDate,
				Direction: "in",
				Type:      types.CashflowSubsidy,
				Amount:    auditEntry.T0Flow,
				Memo:      fmt.Sprintf("Campaign %s subsidy", campaign.ID),
			}
			result.T0Flows = append(result.T0Flows, t0Flow)
		}
	}

	// Calculate total impact
	result.TotalImpact = e.calculateTotalImpact(result.OriginalDeal, result.TransformedDeal, result.T0Flows)

	return result, nil
}

// sortCampaigns sorts campaigns by their stacking order
func (e *Engine) sortCampaigns(campaigns []types.Campaign) []types.Campaign {
	// Define stacking order as per spec (with new base/benchmark rows at the top):
	// Base (no subsidy) → Base (subsidy included) → Subdown → Subinterest → Free Insurance → Free MBSP → Cash Discount
	stackingOrder := map[types.CampaignType]int{
		types.CampaignBaseNoSubsidy: 0,
		types.CampaignBaseSubsidy:   1,
		types.CampaignSubdown:       2,
		types.CampaignSubinterest:   3,
		types.CampaignFreeInsurance: 4,
		types.CampaignFreeMBSP:      5,
		types.CampaignCashDiscount:  6,
	}

	sorted := make([]types.Campaign, len(campaigns))
	copy(sorted, campaigns)

	sort.Slice(sorted, func(i, j int) bool {
		orderI := stackingOrder[sorted[i].Type]
		orderJ := stackingOrder[sorted[j].Type]
		return orderI < orderJ
	})

	return sorted
}

// applySingleCampaign applies a single campaign and returns audit entry
func (e *Engine) applySingleCampaign(deal *types.Deal, campaign types.Campaign) (types.CampaignAuditEntry, error) {
	auditEntry := types.CampaignAuditEntry{
		CampaignID:            campaign.ID,
		CampaignType:          campaign.Type,
		Applied:               false,
		Impact:                decimal.Zero,
		T0Flow:                decimal.Zero,
		TransformationDetails: make(map[string]interface{}),
	}

	switch campaign.Type {
	case types.CampaignBaseNoSubsidy:
		// Benchmark row: do nothing to deal; no T0 flow.
		auditEntry.Applied = true
		auditEntry.Description = "Benchmark: Base (no subsidy)"
		return auditEntry, nil

	case types.CampaignBaseSubsidy:
		// Benchmark row: inject T0 subsidy equal to SubsidyAmount or derived from SubsidyPercent of price.
		auditEntry.Applied = true
		amt := campaign.SubsidyAmount
		if amt.IsZero() && campaign.SubsidyPercent.GreaterThan(decimal.Zero) {
			amt = deal.PriceExTax.Mul(campaign.SubsidyPercent)
		}
		amt = types.RoundTHB(amt)
		if amt.GreaterThan(decimal.Zero) {
			auditEntry.Impact = amt
			auditEntry.T0Flow = amt
			auditEntry.Description = fmt.Sprintf("Benchmark: Base (subsidy included) THB %s", amt.StringFixed(0))
		} else {
			auditEntry.Description = "Benchmark: Base (subsidy included) with THB 0"
		}
		return auditEntry, nil

	case types.CampaignSubdown:
		return e.applySubdown(deal, campaign)

	case types.CampaignSubinterest:
		return e.applySubinterest(deal, campaign)

	case types.CampaignFreeInsurance:
		return e.applyFreeInsurance(deal, campaign)

	case types.CampaignFreeMBSP:
		return e.applyFreeMBSP(deal, campaign)

	case types.CampaignCashDiscount:
		return e.applyCashDiscount(deal, campaign)

	default:
		auditEntry.Description = "Unknown campaign type"
		return auditEntry, errors.New("unknown campaign type")
	}
}

// applySubdown applies a subdown campaign
func (e *Engine) applySubdown(deal *types.Deal, campaign types.Campaign) (types.CampaignAuditEntry, error) {
	auditEntry := types.CampaignAuditEntry{
		CampaignID:            campaign.ID,
		CampaignType:          campaign.Type,
		Applied:               true,
		TransformationDetails: make(map[string]interface{}),
	}

	// Calculate subsidy amount
	subsidyAmount := campaign.SubsidyAmount
	if campaign.SubsidyPercent.GreaterThan(decimal.Zero) {
		subsidyAmount = deal.PriceExTax.Mul(campaign.SubsidyPercent)
	}
	subsidyAmount = types.RoundTHB(subsidyAmount)

	// Store original values for audit
	originalDownPayment := deal.DownPaymentAmount
	originalFinanced := deal.FinancedAmount

	// Apply subdown as effective increase in down payment
	deal.DownPaymentAmount = deal.DownPaymentAmount.Add(subsidyAmount)
	deal.FinancedAmount = deal.PriceExTax.Sub(deal.DownPaymentAmount)

	// Update percentage if needed
	if deal.DownPaymentAmount.GreaterThan(decimal.Zero) {
		deal.DownPaymentPercent = deal.DownPaymentAmount.Div(deal.PriceExTax)
	}

	// Set audit details
	auditEntry.Impact = subsidyAmount
	auditEntry.T0Flow = subsidyAmount
	auditEntry.Description = fmt.Sprintf("Subdown subsidy of THB %s applied", subsidyAmount.StringFixed(2))
	auditEntry.TransformationDetails["original_down_payment"] = originalDownPayment.StringFixed(2)
	auditEntry.TransformationDetails["new_down_payment"] = deal.DownPaymentAmount.StringFixed(2)
	auditEntry.TransformationDetails["original_financed"] = originalFinanced.StringFixed(2)
	auditEntry.TransformationDetails["new_financed"] = deal.FinancedAmount.StringFixed(2)

	return auditEntry, nil
}

// applySubinterest applies a subinterest campaign
func (e *Engine) applySubinterest(deal *types.Deal, campaign types.Campaign) (types.CampaignAuditEntry, error) {
	auditEntry := types.CampaignAuditEntry{
		CampaignID:            campaign.ID,
		CampaignType:          campaign.Type,
		Applied:               true,
		TransformationDetails: make(map[string]interface{}),
	}

	// Store original rate
	originalRate := deal.CustomerNominalRate

	// Apply target rate
	if campaign.TargetRate.GreaterThan(decimal.Zero) && campaign.TargetRate.LessThan(originalRate) {
		// Calculate PV difference for subsidy
		subsidy := e.calculateSubinterestSubsidy(deal, originalRate, campaign.TargetRate)

		// Update deal with new rate
		deal.CustomerNominalRate = campaign.TargetRate
		deal.RateMode = "fixed_rate"

		auditEntry.Impact = campaign.TargetRate.Sub(originalRate)
		auditEntry.T0Flow = subsidy
		auditEntry.Description = fmt.Sprintf("Subinterest from %s%% to %s%%, subsidy THB %s",
			originalRate.Mul(decimal.NewFromInt(100)).StringFixed(2),
			campaign.TargetRate.Mul(decimal.NewFromInt(100)).StringFixed(2),
			subsidy.StringFixed(2))

		auditEntry.TransformationDetails["original_rate"] = originalRate.StringFixed(4)
		auditEntry.TransformationDetails["target_rate"] = campaign.TargetRate.StringFixed(4)
		auditEntry.TransformationDetails["subsidy_amount"] = subsidy.StringFixed(2)
	} else {
		auditEntry.Applied = false
		auditEntry.Description = "Subinterest not applicable (target rate not lower)"
	}

	return auditEntry, nil
}

// applyFreeInsurance applies a free insurance campaign
func (e *Engine) applyFreeInsurance(deal *types.Deal, campaign types.Campaign) (types.CampaignAuditEntry, error) {
	auditEntry := types.CampaignAuditEntry{
		CampaignID:            campaign.ID,
		CampaignType:          campaign.Type,
		Applied:               true,
		TransformationDetails: make(map[string]interface{}),
	}

	// Calculate insurance cost
	insuranceCost := campaign.InsuranceCost
	if insuranceCost.IsZero() {
		// Default calculation based on financed amount and term
		insuranceCost = deal.FinancedAmount.Mul(decimal.NewFromFloat(0.015)).Mul(
			decimal.NewFromInt(int64(deal.TermMonths)).Div(decimal.NewFromInt(12)),
		)
	}
	insuranceCost = types.RoundTHB(insuranceCost)

	// Free insurance means T0 inflow from funder
	auditEntry.Impact = insuranceCost
	auditEntry.T0Flow = insuranceCost
	auditEntry.Description = fmt.Sprintf("Free insurance worth THB %s", insuranceCost.StringFixed(2))
	auditEntry.TransformationDetails["insurance_cost"] = insuranceCost.StringFixed(2)
	auditEntry.TransformationDetails["funder"] = campaign.Funder

	return auditEntry, nil
}

// applyFreeMBSP applies a free MBSP campaign
func (e *Engine) applyFreeMBSP(deal *types.Deal, campaign types.Campaign) (types.CampaignAuditEntry, error) {
	auditEntry := types.CampaignAuditEntry{
		CampaignID:            campaign.ID,
		CampaignType:          campaign.Type,
		Applied:               true,
		TransformationDetails: make(map[string]interface{}),
	}

	// Calculate MBSP cost
	mbspCost := campaign.MBSPCost
	if mbspCost.IsZero() {
		// Default calculation based on financed amount
		mbspCost = deal.FinancedAmount.Mul(decimal.NewFromFloat(0.01))
	}
	mbspCost = types.RoundTHB(mbspCost)

	// Free MBSP means T0 inflow from funder
	auditEntry.Impact = mbspCost
	auditEntry.T0Flow = mbspCost
	auditEntry.Description = fmt.Sprintf("Free MBSP worth THB %s", mbspCost.StringFixed(2))
	auditEntry.TransformationDetails["mbsp_cost"] = mbspCost.StringFixed(2)
	auditEntry.TransformationDetails["funder"] = campaign.Funder

	return auditEntry, nil
}

// applyCashDiscount applies a cash discount campaign
func (e *Engine) applyCashDiscount(deal *types.Deal, campaign types.Campaign) (types.CampaignAuditEntry, error) {
	auditEntry := types.CampaignAuditEntry{
		CampaignID:            campaign.ID,
		CampaignType:          campaign.Type,
		Applied:               true,
		TransformationDetails: make(map[string]interface{}),
	}

	// Calculate discount amount
	discountAmount := campaign.DiscountAmount
	if campaign.DiscountPercent.GreaterThan(decimal.Zero) {
		discountAmount = deal.PriceExTax.Mul(campaign.DiscountPercent)
	}
	discountAmount = types.RoundTHB(discountAmount)

	// Store original values
	originalPrice := deal.PriceExTax
	originalFinanced := deal.FinancedAmount

	// Apply discount to price
	deal.PriceExTax = deal.PriceExTax.Sub(discountAmount)

	// Recalculate financed amount
	deal.FinancedAmount = deal.PriceExTax.Sub(deal.DownPaymentAmount)

	// Ensure financed amount is positive
	if deal.FinancedAmount.LessThanOrEqual(decimal.Zero) {
		auditEntry.Applied = false
		auditEntry.Description = "Cash discount would result in negative financed amount"
		// Restore original values
		deal.PriceExTax = originalPrice
		deal.FinancedAmount = originalFinanced
		return auditEntry, nil
	}

	auditEntry.Impact = discountAmount
	auditEntry.Description = fmt.Sprintf("Cash discount of THB %s applied", discountAmount.StringFixed(2))
	auditEntry.TransformationDetails["original_price"] = originalPrice.StringFixed(2)
	auditEntry.TransformationDetails["new_price"] = deal.PriceExTax.StringFixed(2)
	auditEntry.TransformationDetails["discount_amount"] = discountAmount.StringFixed(2)
	auditEntry.TransformationDetails["original_financed"] = originalFinanced.StringFixed(2)
	auditEntry.TransformationDetails["new_financed"] = deal.FinancedAmount.StringFixed(2)

	return auditEntry, nil
}

// calculateSubinterestSubsidy calculates the PV difference for subinterest
func (e *Engine) calculateSubinterestSubsidy(deal *types.Deal, originalRate, targetRate decimal.Decimal) decimal.Decimal {
	// Calculate PV at original rate
	originalMonthlyRate := originalRate.Div(decimal.NewFromInt(12))
	targetMonthlyRate := targetRate.Div(decimal.NewFromInt(12))

	pvOriginal := e.calculatePV(deal.FinancedAmount, originalMonthlyRate, deal.TermMonths)
	pvTarget := e.calculatePV(deal.FinancedAmount, targetMonthlyRate, deal.TermMonths)

	// Subsidy is the difference in PV
	subsidy := pvTarget.Sub(pvOriginal)
	if subsidy.LessThan(decimal.Zero) {
		subsidy = subsidy.Abs()
	}

	return types.RoundTHB(subsidy)
}

// calculatePV calculates present value of a loan
func (e *Engine) calculatePV(principal, monthlyRate decimal.Decimal, termMonths int) decimal.Decimal {
	if monthlyRate.IsZero() {
		return principal
	}

	// PV = PMT * (1 - (1 + r)^-n) / r
	// First calculate PMT
	onePlusRate := decimal.NewFromFloat(1).Add(monthlyRate)
	factor := decimal.NewFromFloat(1).Sub(
		decimal.NewFromFloat(1).Div(
			decimal.NewFromFloat(float64(termMonths)).Mul(onePlusRate),
		),
	)

	pmt := principal.Mul(monthlyRate).Div(factor)

	// Now calculate total payments PV
	totalPayments := pmt.Mul(decimal.NewFromInt(int64(termMonths)))

	return totalPayments
}

// calculateTotalImpact calculates the total impact of campaigns
func (e *Engine) calculateTotalImpact(originalDeal, transformedDeal types.Deal, t0Flows []types.Cashflow) decimal.Decimal {
	impact := decimal.Zero

	// Calculate financing impact
	financingReduction := originalDeal.FinancedAmount.Sub(transformedDeal.FinancedAmount)
	impact = impact.Add(financingReduction)

	// Add T0 subsidies
	for _, flow := range t0Flows {
		if flow.Type == types.CashflowSubsidy {
			impact = impact.Add(flow.Amount)
		}
	}

	return impact
}

// CampaignResult contains the results of campaign application
type CampaignResult struct {
	OriginalDeal    types.Deal
	TransformedDeal types.Deal
	AuditEntries    []types.CampaignAuditEntry
	T0Flows         []types.Cashflow
	TotalImpact     decimal.Decimal
}

// ValidateCampaignEligibility checks if a campaign is eligible for a deal
func (e *Engine) ValidateCampaignEligibility(deal types.Deal, campaign types.Campaign) bool {
	// Check product eligibility
	if eligibleProducts, ok := campaign.Eligibility["products"].([]string); ok {
		productEligible := false
		for _, product := range eligibleProducts {
			if string(deal.Product) == product {
				productEligible = true
				break
			}
		}
		if !productEligible {
			return false
		}
	}

	// Check minimum financed amount
	if minFinanced, ok := campaign.Eligibility["min_financed"].(float64); ok {
		if deal.FinancedAmount.LessThan(decimal.NewFromFloat(minFinanced)) {
			return false
		}
	}

	// Check maximum term
	if maxTerm, ok := campaign.Eligibility["max_term"].(int); ok {
		if deal.TermMonths > maxTerm {
			return false
		}
	}

	// Check minimum down payment
	if minDown, ok := campaign.Eligibility["min_down_percent"].(float64); ok {
		if deal.DownPaymentPercent.LessThan(decimal.NewFromFloat(minDown)) {
			return false
		}
	}

	return true
}

// commissionLookup is the minimal dependency campaigns needs; compatible with calculator.CommissionLookup without importing it.
type commissionLookup interface {
	CommissionPercentByProduct(product string) float64
}

// isCashDiscount reports whether the given campaign type is Cash Discount.
func isCashDiscount(t types.CampaignType) bool {
	return t == types.CampaignCashDiscount
}

// GenerateCampaignSummaries computes per-option Dealer Commission (THB and percent) for UI tiles.
// - Cash Discount options are forced to 0 THB (0%).
// - Finance options use override precedence (Amt > Pct > Auto) per Dealer Commission Policy.
// - Auto mode uses commission percent by product from the injected provider.
// - Financed base prefers deal.FinancedAmount; otherwise PriceExTax - DownPaymentAmount; clamped to >= 0 and amounts are rounded to nearest THB.
func (e *Engine) GenerateCampaignSummaries(deal types.Deal, state types.DealState, campaigns []types.Campaign) []types.CampaignSummary {
	// Sort for deterministic tile order (same as stacking)
	sorted := e.sortCampaigns(campaigns)
	summaries := make([]types.CampaignSummary, 0, len(sorted))

	// Determine financed base (exclude financed IDCs): always PriceExTax - DownPaymentAmount
	financedBase := deal.PriceExTax.Sub(deal.DownPaymentAmount).InexactFloat64()
	if financedBase < 0 {
		financedBase = 0
	}

	product := string(deal.Product)

	for _, c := range sorted {
		var amt float64
		var pct float64

		if isCashDiscount(c.Type) {
			amt = 0
			pct = 0
		} else {
			// Override -> Auto precedence
			if state.DealerCommission.Mode == types.DealerCommissionModeOverride {
				if state.DealerCommission.Amt != nil {
					// Amount override takes precedence
					a := *state.DealerCommission.Amt
					if a < 0 {
						a = 0
					}
					amt = math.Round(a)
					pct = 0
				} else if state.DealerCommission.Pct != nil {
					// Percent override
					p := *state.DealerCommission.Pct
					if p < 0 {
						p = 0
					}
					pct = p
					amt = math.Round(math.Max(financedBase, 0) * pct)
					if amt < 0 {
						amt = 0
					}
				} else {
					// Override mode without values -> treat as auto
					if e.commission != nil {
						pct = e.commission.CommissionPercentByProduct(product)
						if pct < 0 {
							pct = 0
						}
					} else {
						pct = 0
					}
					amt = math.Round(math.Max(financedBase, 0) * pct)
					if amt < 0 {
						amt = 0
					}
				}
			} else {
				// Auto mode
				if e.commission != nil {
					pct = e.commission.CommissionPercentByProduct(product)
					if pct < 0 {
						pct = 0
					}
				} else {
					pct = 0
				}
				amt = math.Round(math.Max(financedBase, 0) * pct)
				if amt < 0 {
					amt = 0
				}
			}
		}

		summaries = append(summaries, types.CampaignSummary{
			CampaignID:          c.ID,
			CampaignType:        c.Type,
			DealerCommissionAmt: amt,
			DealerCommissionPct: pct,
		})
	}

	return summaries
}
