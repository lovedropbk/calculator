package campaigns

// MARK: Subinterest solvers — PV convention, tolerances, rounding
//
// PV convention:
// - Use the rounded periodic schedule generated by pricing.NewEngine(...).BuildAmortizationSchedule.
// - Discount each periodic Amount at the schedule's own nominal annual rate r using monthly compounding:
//     PV = sum_{i=1..N} Payment_i / (1 + r/12)^i
//   where i is the month index starting at 1. Balloon entries are included as an additional discounted flow.
// - Do not day-count or interpolate; monthly frequency only.
//
// Solver tolerances and limits:
// - PV tolerance: 0.01 THB absolute on (PV_base − PV_target − Budget) for budget solve.
// - Rate tolerance: 1 basis point (1e-4 as a fraction) on |r_hi − r_lo| in bisection.
// - Max iterations: 100.
// - Rates are rounded to basis points for outputs; THB amounts to nearest THB.
// - Deterministic and pure: no global state; all inputs explicit.
//
// Diagnostics (explicit codes):
// - "invalid_inputs"
// - "insufficient_budget_to_move_rate"
// - "exceeded_budget_manual_override"
// - "convergence_failure"
//
// Notes:
// - When budget is excessive, SubinterestByBudget clips to min rate and reports residual in ExceedTHB.
// - When budget is insufficient (≤ 0), SubinterestByBudget returns r_base with subsidyUsed=0 and diagnostic.
// - Manual target variant (SubinterestByTarget) sets OverBudget and ExceedTHB when required subsidy exceeds provided budget.
// - Profitability waterfall relies on nominal basis alignment (GIM) implemented in profitability engine.

import (
	"fmt"

	"github.com/financial-calculator/engines/cashflow"
	"github.com/financial-calculator/engines/pricing"
	"github.com/financial-calculator/engines/profitability"
	"github.com/financial-calculator/engines/types"
	"github.com/shopspring/decimal"
)

// SubinterestByBudget finds the lowest possible nominal annual rate r_target ≤ r_base
// such that PV_base − PV_target(r_target) ≈ BudgetTHB within 0.01 THB (or until rate span ≤ 1 bp).
// If budget is excessive, it clips at min rate and reports residual ExceedTHB.
// If budget ≤ 0, returns r_base with subsidyUsed=0 and diagnostic "insufficient_budget_to_move_rate".
func SubinterestByBudget(input types.CampaignBudgetInput) (types.CampaignResult, error) {
	var out types.CampaignResult
	out.Diagnostics = map[string]string{}
	out.ParameterSetVersionID = input.ParameterSet.Version

	// Validate input
	if input.Deal.TermMonths <= 0 || input.Deal.FinancedAmount.LessThanOrEqual(decimal.Zero) {
		out.Error = &types.CampaignError{
			Code:    "invalid_inputs",
			Summary: "Invalid deal terms",
			Detail:  "TermMonths must be positive and FinancedAmount must be > 0",
		}
		return out, fmt.Errorf("invalid inputs")
	}

	// Build engines
	pEng := pricing.NewEngine(input.ParameterSet)
	cfEng := cashflow.NewEngine(input.ParameterSet)
	prof := profitability.NewEngine(input.ParameterSet)

	// Establish base rate and schedule from the deal (supports fixed_rate or target_installment).
	baseRate, baseSched, baseInstallment, err := resolveBasePricing(pEng, input.Deal)
	if err != nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Pricing failed", Detail: err.Error()}
		return out, err
	}

	// Quick insufficient budget path: budget ≤ 0
	if input.BudgetTHB.LessThanOrEqual(decimal.Zero) {
		// Build cashflows with zero subsidy
		t0 := cfEng.ConstructT0Flows(input.Deal, nil, nil)
		allCF := cfEng.MergeCashflows(t0, baseSched)
		dealIRR, _ := cfEng.CalculateDealIRR(t0, baseSched, nil)
		wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

		out.Metrics = types.CampaignMetrics{
			CustomerNominalRate:         types.RoundBasisPoints(baseRate),
			CustomerEffectiveRate:       pEng.CalculateEffectiveRate(baseRate, 12),
			MonthlyInstallment:          baseInstallment,
			SubsidyUsedTHB:              decimal.Zero,
			RequiredSubsidyTHB:          decimal.Zero,
			ExceedTHB:                   decimal.Zero,
			OverBudget:                  false,
			DealerCommissionResolvedTHB: decimal.Zero,
			DealerCommissionPctResolved: decimal.Zero,
			IDCTotalTHB:                 decimal.Zero,
			AcquisitionRoRAC:            wf.AcquisitionRoRAC,
			NetEBITMargin:               wf.NetEBITMargin,
			EconomicCapital:             wf.EconomicCapital,
		}
		out.Schedule = baseSched
		out.Cashflows = allCF
		out.Diagnostics["insufficient_budget_to_move_rate"] = "budget ≤ 0; no rate movement"
		out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
		return out, nil
	}

	// Define caps
	minCap := decimal.NewFromFloat(0.0001) // default 0.01% nominal
	maxCap := baseRate
	if input.RateCaps != nil {
		if input.RateCaps.MinNominal.GreaterThan(decimal.Zero) {
			minCap = input.RateCaps.MinNominal
		}
		if input.RateCaps.MaxNominal.GreaterThan(decimal.Zero) {
			maxCap = input.RateCaps.MaxNominal
			if maxCap.GreaterThan(baseRate) {
				maxCap = baseRate // cannot exceed base
			}
		}
	}
	if maxCap.LessThan(minCap) {
		maxCap = minCap
	}

	// Precompute PV_base using base schedule discounted at base nominal rate
	pvBase := pvOfScheduleAtRate(baseSched, baseRate)

	// Check clip conditions at min rate
	pvAtMinSched, _ := pEng.BuildAmortizationSchedule(input.Deal, minCap)
	// Discount target schedule at base rate per subsidy PV convention
	pvAtMin := pvOfScheduleAtRate(pvAtMinSched, baseRate)
	maxAchievable := pvBase.Sub(pvAtMin) // PV difference if we drop to min
	if maxAchievable.LessThanOrEqual(decimal.Zero) {
		// No movement possible (schedule rounding likely equal)
		return finalizeBudgetResult(input, out, baseRate, baseSched, baseInstallment, decimal.Zero, decimal.Zero, "insufficient_budget_to_move_rate", pEng, cfEng, prof)
	}
	if maxAchievable.Add(decimal.NewFromFloat(0.01).Neg()).LessThan(input.BudgetTHB.Neg()) {
		// This condition is protective; proper excessive budget check below
	}

	// If budget exceeds achievable PV diff, clip at min rate
	if maxAchievable.Add(decimal.NewFromFloat(0.01)).LessThan(input.BudgetTHB) || maxAchievable.Equal(input.BudgetTHB) {
		used := types.RoundTHB(maxAchievable)
		exceed := types.RoundTHB(input.BudgetTHB.Sub(used))
		// Build CF and profitability at min rate with subsidy 'used'
		instMin, _ := pEng.CalculateInstallment(input.Deal.FinancedAmount, minCap, input.Deal.TermMonths, input.Deal.BalloonAmount)
		tSched := pvAtMinSched
		t0 := []types.Cashflow{{
			Date:      input.Deal.PayoutDate,
			Direction: "in",
			Type:      types.CashflowSubsidy,
			Amount:    used,
			Memo:      "Subinterest subsidy (clipped at min rate)",
		}}
		t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
		allCF := cfEng.MergeCashflows(t0, tSched)
		dealIRR, _ := cfEng.CalculateDealIRR(t0, tSched, nil)
		wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

		out.Metrics = types.CampaignMetrics{
			CustomerNominalRate:         types.RoundBasisPoints(minCap),
			CustomerEffectiveRate:       pEng.CalculateEffectiveRate(minCap, 12),
			MonthlyInstallment:          instMin,
			SubsidyUsedTHB:              used,
			RequiredSubsidyTHB:          used,
			ExceedTHB:                   exceed,
			OverBudget:                  false,
			DealerCommissionResolvedTHB: decimal.Zero,
			DealerCommissionPctResolved: decimal.Zero,
			IDCTotalTHB:                 decimal.Zero,
			AcquisitionRoRAC:            wf.AcquisitionRoRAC,
			NetEBITMargin:               wf.NetEBITMargin,
			EconomicCapital:             wf.EconomicCapital,
		}
		out.Schedule = tSched
		out.Cashflows = allCF
		out.Diagnostics["clipped_at_min_rate"] = "budget exceeded achievable PV difference; clipped at min nominal rate"
		out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
		return out, nil
	}

	// Otherwise, solve via bisection for target rate achieving budget within tolerance
	targetRate, usedSubsidy, tSched, tInst, convErr := solveRateForBudget(pEng, input.Deal, pvBase, input.BudgetTHB, baseRate, minCap, maxCap)
	if convErr != nil {
		out.Error = &types.CampaignError{Code: "convergence_failure", Summary: "Bisection did not converge", Detail: convErr.Error()}
		// Best effort: return base
		return out, convErr
	}

	// Clamp used subsidy to budget to satisfy public API contract (never exceed budget)
	usedClamped := usedSubsidy
	if usedClamped.GreaterThan(input.BudgetTHB) {
		usedClamped = input.BudgetTHB
	}
	usedRounded := types.RoundTHB(usedClamped)

	// Build cashflows and profitability at solution (using rounded, clamped T0 subsidy)
	t0 := []types.Cashflow{{
		Date:      input.Deal.PayoutDate,
		Direction: "in",
		Type:      types.CashflowSubsidy,
		Amount:    usedRounded,
		Memo:      "Subinterest subsidy",
	}}
	t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
	allCF := cfEng.MergeCashflows(t0, tSched)
	dealIRR, _ := cfEng.CalculateDealIRR(t0, tSched, nil)
	wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

	out.Metrics = types.CampaignMetrics{
		CustomerNominalRate:         types.RoundBasisPoints(targetRate),
		CustomerEffectiveRate:       pEng.CalculateEffectiveRate(targetRate, 12),
		MonthlyInstallment:          tInst,
		SubsidyUsedTHB:              usedRounded,
		RequiredSubsidyTHB:          usedRounded,
		ExceedTHB:                   decimal.Zero,
		OverBudget:                  false,
		DealerCommissionResolvedTHB: decimal.Zero,
		DealerCommissionPctResolved: decimal.Zero,
		IDCTotalTHB:                 decimal.Zero,
		AcquisitionRoRAC:            wf.AcquisitionRoRAC,
		NetEBITMargin:               wf.NetEBITMargin,
		EconomicCapital:             wf.EconomicCapital,
	}
	out.Schedule = tSched
	out.Cashflows = allCF
	out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
	return out, nil
}

// SubinterestByTarget computes the required subsidy to reach a manual target (rate or installment).
//   - If TargetNominalRate is provided, it is used directly (subject to caps).
//   - If TargetInstallment is provided, nominal rate is solved first.
//   - If BudgetTHB is provided and less than the required subsidy, OverBudget is set true and
//     SubsidyUsedTHB is clipped to BudgetTHB; ExceedTHB = Required − Budget; profitability uses the used amount.
func SubinterestByTarget(input types.CampaignRateInput) (types.CampaignResult, error) {
	var out types.CampaignResult
	out.Diagnostics = map[string]string{}
	out.ParameterSetVersionID = input.ParameterSet.Version

	// Validate input
	if input.Deal.TermMonths <= 0 || input.Deal.FinancedAmount.LessThanOrEqual(decimal.Zero) {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Invalid deal terms", Detail: "TermMonths must be positive and FinancedAmount must be > 0"}
		return out, fmt.Errorf("invalid inputs")
	}

	pEng := pricing.NewEngine(input.ParameterSet)
	cfEng := cashflow.NewEngine(input.ParameterSet)
	prof := profitability.NewEngine(input.ParameterSet)

	// Determine base (r_base, schedule, installment)
	baseRate, baseSched, _, err := resolveBasePricing(pEng, input.Deal)
	if err != nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Pricing failed", Detail: err.Error()}
		return out, err
	}
	pvBase := pvOfScheduleAtRate(baseSched, baseRate)

	// Determine target nominal rate
	var targetRate decimal.Decimal
	var targetSched []types.Cashflow
	var targetInstallment decimal.Decimal

	rateCapsMin := decimal.NewFromFloat(0.0001)
	if input.RateCaps != nil && input.RateCaps.MinNominal.GreaterThan(decimal.Zero) {
		rateCapsMin = input.RateCaps.MinNominal
	}
	var rateCapsMax decimal.Decimal
	if input.RateCaps != nil && input.RateCaps.MaxNominal.GreaterThan(decimal.Zero) && input.RateCaps.MaxNominal.LessThan(baseRate) {
		rateCapsMax = input.RateCaps.MaxNominal
	} else {
		rateCapsMax = baseRate
	}

	if input.TargetNominalRate != nil && input.TargetInstallment != nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Ambiguous target", Detail: "Provide either TargetNominalRate or TargetInstallment, not both"}
		return out, fmt.Errorf("invalid inputs")
	}
	if input.TargetNominalRate == nil && input.TargetInstallment == nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Missing target", Detail: "TargetNominalRate or TargetInstallment is required"}
		return out, fmt.Errorf("invalid inputs")
	}

	if input.TargetNominalRate != nil {
		targetRate = *input.TargetNominalRate
		// apply caps
		if targetRate.LessThan(rateCapsMin) {
			targetRate = rateCapsMin
		}
		if targetRate.GreaterThan(rateCapsMax) {
			targetRate = rateCapsMax
		}
		targetSched, err = pEng.BuildAmortizationSchedule(input.Deal, targetRate)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot build schedule at target rate", Detail: err.Error()}
			return out, err
		}
		targetInstallment, err = pEng.CalculateInstallment(input.Deal.FinancedAmount, targetRate, input.Deal.TermMonths, input.Deal.BalloonAmount)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot calc installment at target rate", Detail: err.Error()}
			return out, err
		}
	} else {
		// Solve nominal rate for target installment using robust bisection within caps
		targetInstallment = *input.TargetInstallment
		solvedRate, solveErr := solveRateForInstallmentBisection(pEng, input.Deal, targetInstallment, rateCapsMin, rateCapsMax)
		if solveErr != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot solve for rate", Detail: solveErr.Error()}
			return out, solveErr
		}
		targetRate = solvedRate
		// Build schedule at solved rate
		targetSched, err = pEng.BuildAmortizationSchedule(input.Deal, targetRate)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot build schedule at solved rate", Detail: err.Error()}
			return out, err
		}
		// Installment at solved rate
		targetInstallment, err = pEng.CalculateInstallment(input.Deal.FinancedAmount, targetRate, input.Deal.TermMonths, input.Deal.BalloonAmount)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot calc installment at rate", Detail: err.Error()}
			return out, err
		}
	}

	// Compute required subsidy from PV difference (discount both at base nominal rate)
	pvTarget := pvOfScheduleAtRate(targetSched, baseRate)
	required := pvBase.Sub(pvTarget)
	if required.LessThan(decimal.Zero) {
		required = required.Abs() // defensive
	}
	required = types.RoundTHB(required)

	// Budget handling
	used := required
	overBudget := false
	exceed := decimal.Zero
	if input.BudgetTHB != nil && input.BudgetTHB.GreaterThanOrEqual(decimal.Zero) {
		if required.GreaterThan(*input.BudgetTHB) {
			overBudget = true
			exceed = types.RoundTHB(required.Sub(*input.BudgetTHB))
			used = types.RoundTHB(*input.BudgetTHB)
			out.Diagnostics["exceeded_budget_manual_override"] = "required subsidy exceeds provided budget; clipped used to budget"
		}
	}

	// Build cashflows and profitability using "used" subsidy at T0
	t0 := []types.Cashflow{{
		Date:      input.Deal.PayoutDate,
		Direction: "in",
		Type:      types.CashflowSubsidy,
		Amount:    used,
		Memo:      "Subinterest subsidy (manual target)",
	}}
	t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
	allCF := cfEng.MergeCashflows(t0, targetSched)
	dealIRR, _ := cfEng.CalculateDealIRR(t0, targetSched, nil)
	wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

	out.Metrics = types.CampaignMetrics{
		CustomerNominalRate:         types.RoundBasisPoints(targetRate),
		CustomerEffectiveRate:       pEng.CalculateEffectiveRate(targetRate, 12),
		MonthlyInstallment:          targetInstallment,
		SubsidyUsedTHB:              used,
		RequiredSubsidyTHB:          required,
		ExceedTHB:                   exceed,
		OverBudget:                  overBudget,
		DealerCommissionResolvedTHB: decimal.Zero,
		DealerCommissionPctResolved: decimal.Zero,
		IDCTotalTHB:                 decimal.Zero,
		AcquisitionRoRAC:            wf.AcquisitionRoRAC,
		NetEBITMargin:               wf.NetEBITMargin,
		EconomicCapital:             wf.EconomicCapital,
	}
	out.Schedule = targetSched
	out.Cashflows = allCF
	out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
	return out, nil
}
