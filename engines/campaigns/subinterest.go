package campaigns

// MARK: Subinterest solvers — PV convention, tolerances, rounding
//
// PV convention:
// - Use the rounded periodic schedule generated by pricing.NewEngine(...).BuildAmortizationSchedule.
// - Discount each periodic Amount at the schedule's own nominal annual rate r using monthly compounding:
//     PV = sum_{i=1..N} Payment_i / (1 + r/12)^i
//   where i is the month index starting at 1. Balloon entries are included as an additional discounted flow.
// - Do not day-count or interpolate; monthly frequency only.
//
// Solver tolerances and limits:
// - PV tolerance: 0.01 THB absolute on (PV_base − PV_target − Budget) for budget solve.
// - Rate tolerance: 1 basis point (1e-4 as a fraction) on |r_hi − r_lo| in bisection.
// - Max iterations: 100.
// - Rates are rounded to basis points for outputs; THB amounts to nearest THB.
// - Deterministic and pure: no global state; all inputs explicit.
//
// Diagnostics (explicit codes):
// - "invalid_inputs"
// - "insufficient_budget_to_move_rate"
// - "exceeded_budget_manual_override"
// - "convergence_failure"
//
// Notes:
// - When budget is excessive, SubinterestByBudget clips to min rate and reports residual in ExceedTHB.
// - When budget is insufficient (≤ 0), SubinterestByBudget returns r_base with subsidyUsed=0 and diagnostic.
// - Manual target variant (SubinterestByTarget) sets OverBudget and ExceedTHB when required subsidy exceeds provided budget.
// - Profitability waterfall relies on nominal basis alignment (GIM) implemented in profitability engine.

import (
	"fmt"
	"math"

	"github.com/financial-calculator/engines/cashflow"
	"github.com/financial-calculator/engines/pricing"
	"github.com/financial-calculator/engines/profitability"
	"github.com/financial-calculator/engines/types"
	"github.com/shopspring/decimal"
)

// SubinterestByBudget finds the lowest possible nominal annual rate r_target ≤ r_base
// such that PV_base − PV_target(r_target) ≈ BudgetTHB within 0.01 THB (or until rate span ≤ 1 bp).
// If budget is excessive, it clips at min rate and reports residual ExceedTHB.
// If budget ≤ 0, returns r_base with subsidyUsed=0 and diagnostic "insufficient_budget_to_move_rate".
func SubinterestByBudget(input types.CampaignBudgetInput) (types.CampaignResult, error) {
	var out types.CampaignResult
	out.Diagnostics = map[string]string{}
	out.ParameterSetVersionID = input.ParameterSet.Version

	// Validate input
	if input.Deal.TermMonths <= 0 || input.Deal.FinancedAmount.LessThanOrEqual(decimal.Zero) {
		out.Error = &types.CampaignError{
			Code:    "invalid_inputs",
			Summary: "Invalid deal terms",
			Detail:  "TermMonths must be positive and FinancedAmount must be > 0",
		}
		return out, fmt.Errorf("invalid inputs")
	}

	// Build engines
	pEng := pricing.NewEngine(input.ParameterSet)
	cfEng := cashflow.NewEngine(input.ParameterSet)
	prof := profitability.NewEngine(input.ParameterSet)

	// Establish base rate and schedule from the deal (supports fixed_rate or target_installment).
	baseRate, baseSched, baseInstallment, err := resolveBasePricing(pEng, input.Deal)
	if err != nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Pricing failed", Detail: err.Error()}
		return out, err
	}

	// Quick insufficient budget path: budget ≤ 0
	if input.BudgetTHB.LessThanOrEqual(decimal.Zero) {
		// Build cashflows with zero subsidy
		t0 := cfEng.ConstructT0Flows(input.Deal, nil, nil)
		allCF := cfEng.MergeCashflows(t0, baseSched)
		dealIRR, _ := cfEng.CalculateDealIRR(t0, baseSched, nil)
		wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

		out.Metrics = types.CampaignMetrics{
			CustomerNominalRate:         types.RoundBasisPoints(baseRate),
			CustomerEffectiveRate:       pEng.CalculateEffectiveRate(baseRate, 12),
			MonthlyInstallment:          baseInstallment,
			SubsidyUsedTHB:              decimal.Zero,
			RequiredSubsidyTHB:          decimal.Zero,
			ExceedTHB:                   decimal.Zero,
			OverBudget:                  false,
			DealerCommissionResolvedTHB: decimal.Zero,
			DealerCommissionPctResolved: decimal.Zero,
			IDCTotalTHB:                 decimal.Zero,
			AcquisitionRoRAC:            wf.AcquisitionRoRAC,
			NetEBITMargin:               wf.NetEBITMargin,
			EconomicCapital:             wf.EconomicCapital,
		}
		out.Schedule = baseSched
		out.Cashflows = allCF
		out.Diagnostics["insufficient_budget_to_move_rate"] = "budget ≤ 0; no rate movement"
		out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
		return out, nil
	}

	// Define caps
	minCap := decimal.NewFromFloat(0.0001) // default 0.01% nominal
	maxCap := baseRate
	if input.RateCaps != nil {
		if input.RateCaps.MinNominal.GreaterThan(decimal.Zero) {
			minCap = input.RateCaps.MinNominal
		}
		if input.RateCaps.MaxNominal.GreaterThan(decimal.Zero) {
			maxCap = input.RateCaps.MaxNominal
			if maxCap.GreaterThan(baseRate) {
				maxCap = baseRate // cannot exceed base
			}
		}
	}
	if maxCap.LessThan(minCap) {
		maxCap = minCap
	}

	// Precompute PV_base using base schedule and base rate
	pvBase := pvOfSchedule(baseSched, baseRate)

	// Check clip conditions at min rate
	pvAtMinSched, _ := pEng.BuildAmortizationSchedule(input.Deal, minCap)
	pvAtMin := pvOfSchedule(pvAtMinSched, minCap)
	maxAchievable := pvBase.Sub(pvAtMin) // PV difference if we drop to min
	if maxAchievable.LessThanOrEqual(decimal.Zero) {
		// No movement possible (schedule rounding likely equal)
		return finalizeBudgetResult(input, out, baseRate, baseSched, baseInstallment, decimal.Zero, decimal.Zero, "insufficient_budget_to_move_rate", pEng, cfEng, prof)
	}
	if maxAchievable.Add(decimal.NewFromFloat(0.01).Neg()).LessThan(input.BudgetTHB.Neg()) {
		// This condition is protective; proper excessive budget check below
	}

	// If budget exceeds achievable PV diff, clip at min rate
	if maxAchievable.Add(decimal.NewFromFloat(0.01)).LessThan(input.BudgetTHB) || maxAchievable.Equal(input.BudgetTHB) {
		used := types.RoundTHB(maxAchievable)
		exceed := types.RoundTHB(input.BudgetTHB.Sub(used))
		// Build CF and profitability at min rate with subsidy 'used'
		instMin, _ := pEng.CalculateInstallment(input.Deal.FinancedAmount, minCap, input.Deal.TermMonths, input.Deal.BalloonAmount)
		tSched := pvAtMinSched
		t0 := []types.Cashflow{{
			Date:      input.Deal.PayoutDate,
			Direction: "in",
			Type:      types.CashflowSubsidy,
			Amount:    used,
			Memo:      "Subinterest subsidy (clipped at min rate)",
		}}
		t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
		allCF := cfEng.MergeCashflows(t0, tSched)
		dealIRR, _ := cfEng.CalculateDealIRR(t0, tSched, nil)
		wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

		out.Metrics = types.CampaignMetrics{
			CustomerNominalRate:         types.RoundBasisPoints(minCap),
			CustomerEffectiveRate:       pEng.CalculateEffectiveRate(minCap, 12),
			MonthlyInstallment:          instMin,
			SubsidyUsedTHB:              used,
			RequiredSubsidyTHB:          used,
			ExceedTHB:                   exceed,
			OverBudget:                  false,
			DealerCommissionResolvedTHB: decimal.Zero,
			DealerCommissionPctResolved: decimal.Zero,
			IDCTotalTHB:                 decimal.Zero,
			AcquisitionRoRAC:            wf.AcquisitionRoRAC,
			NetEBITMargin:               wf.NetEBITMargin,
			EconomicCapital:             wf.EconomicCapital,
		}
		out.Schedule = tSched
		out.Cashflows = allCF
		out.Diagnostics["clipped_at_min_rate"] = "budget exceeded achievable PV difference; clipped at min nominal rate"
		out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
		return out, nil
	}

	// Otherwise, solve via bisection for target rate achieving budget within tolerance
	targetRate, usedSubsidy, tSched, tInst, convErr := solveRateForBudget(pEng, input.Deal, pvBase, input.BudgetTHB, minCap, maxCap)
	if convErr != nil {
		out.Error = &types.CampaignError{Code: "convergence_failure", Summary: "Bisection did not converge", Detail: convErr.Error()}
		// Best effort: return base
		return out, convErr
	}

	// Build cashflows and profitability at solution
	t0 := []types.Cashflow{{
		Date:      input.Deal.PayoutDate,
		Direction: "in",
		Type:      types.CashflowSubsidy,
		Amount:    types.RoundTHB(usedSubsidy),
		Memo:      "Subinterest subsidy",
	}}
	t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
	allCF := cfEng.MergeCashflows(t0, tSched)
	dealIRR, _ := cfEng.CalculateDealIRR(t0, tSched, nil)
	wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

	out.Metrics = types.CampaignMetrics{
		CustomerNominalRate:         types.RoundBasisPoints(targetRate),
		CustomerEffectiveRate:       pEng.CalculateEffectiveRate(targetRate, 12),
		MonthlyInstallment:          tInst,
		SubsidyUsedTHB:              types.RoundTHB(usedSubsidy),
		RequiredSubsidyTHB:          types.RoundTHB(usedSubsidy),
		ExceedTHB:                   decimal.Zero,
		OverBudget:                  false,
		DealerCommissionResolvedTHB: decimal.Zero,
		DealerCommissionPctResolved: decimal.Zero,
		IDCTotalTHB:                 decimal.Zero,
		AcquisitionRoRAC:            wf.AcquisitionRoRAC,
		NetEBITMargin:               wf.NetEBITMargin,
		EconomicCapital:             wf.EconomicCapital,
	}
	out.Schedule = tSched
	out.Cashflows = allCF
	out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
	return out, nil
}

// SubinterestByTarget computes the required subsidy to reach a manual target (rate or installment).
//   - If TargetNominalRate is provided, it is used directly (subject to caps).
//   - If TargetInstallment is provided, nominal rate is solved first.
//   - If BudgetTHB is provided and less than the required subsidy, OverBudget is set true and
//     SubsidyUsedTHB is clipped to BudgetTHB; ExceedTHB = Required − Budget; profitability uses the used amount.
func SubinterestByTarget(input types.CampaignRateInput) (types.CampaignResult, error) {
	var out types.CampaignResult
	out.Diagnostics = map[string]string{}
	out.ParameterSetVersionID = input.ParameterSet.Version

	// Validate input
	if input.Deal.TermMonths <= 0 || input.Deal.FinancedAmount.LessThanOrEqual(decimal.Zero) {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Invalid deal terms", Detail: "TermMonths must be positive and FinancedAmount must be > 0"}
		return out, fmt.Errorf("invalid inputs")
	}

	pEng := pricing.NewEngine(input.ParameterSet)
	cfEng := cashflow.NewEngine(input.ParameterSet)
	prof := profitability.NewEngine(input.ParameterSet)

	// Determine base (r_base, schedule, installment)
	baseRate, baseSched, _, err := resolveBasePricing(pEng, input.Deal)
	if err != nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Pricing failed", Detail: err.Error()}
		return out, err
	}
	pvBase := pvOfSchedule(baseSched, baseRate)

	// Determine target nominal rate
	var targetRate decimal.Decimal
	var targetSched []types.Cashflow
	var targetInstallment decimal.Decimal

	rateCapsMin := decimal.NewFromFloat(0.0001)
	rateCapsMax := decimal.NewFromFloat(math.Max(baseRate.InexactFloat64(), 0))
	if input.RateCaps != nil {
		if input.RateCaps.MinNominal.GreaterThan(decimal.Zero) {
			rateCapsMin = input.RateCaps.MinNominal
		}
		if input.RateCaps.MaxNominal.GreaterThan(decimal.Zero) && input.RateCaps.MaxNominal.LessThan(baseRate) {
			rateCapsMax = input.RateCaps.MaxNominal
		} else {
			rateCapsMax = baseRate
		}
	} else {
		rateCapsMax = baseRate
	}

	if input.TargetNominalRate != nil && input.TargetInstallment != nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Ambiguous target", Detail: "Provide either TargetNominalRate or TargetInstallment, not both"}
		return out, fmt.Errorf("invalid inputs")
	}
	if input.TargetNominalRate == nil && input.TargetInstallment == nil {
		out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Missing target", Detail: "TargetNominalRate or TargetInstallment is required"}
		return out, fmt.Errorf("invalid inputs")
	}

	if input.TargetNominalRate != nil {
		targetRate = *input.TargetNominalRate
		// apply caps
		if targetRate.LessThan(rateCapsMin) {
			targetRate = rateCapsMin
		}
		if targetRate.GreaterThan(rateCapsMax) {
			targetRate = rateCapsMax
		}
		targetSched, err = pEng.BuildAmortizationSchedule(input.Deal, targetRate)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot build schedule at target rate", Detail: err.Error()}
			return out, err
		}
		targetInstallment, err = pEng.CalculateInstallment(input.Deal.FinancedAmount, targetRate, input.Deal.TermMonths, input.Deal.BalloonAmount)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot calc installment at target rate", Detail: err.Error()}
			return out, err
		}
	} else {
		// Solve nominal rate for target installment
		targetInstallment = *input.TargetInstallment
		solvedRate, solveErr := pEng.SolveForRate(input.Deal.FinancedAmount, targetInstallment, input.Deal.TermMonths, input.Deal.BalloonAmount)
		if solveErr != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot solve for rate", Detail: solveErr.Error()}
			return out, solveErr
		}
		targetRate = solvedRate
		// caps
		if targetRate.LessThan(rateCapsMin) {
			targetRate = rateCapsMin
		}
		if targetRate.GreaterThan(rateCapsMax) {
			targetRate = rateCapsMax
		}
		targetSched, err = pEng.BuildAmortizationSchedule(input.Deal, targetRate)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot build schedule at solved rate", Detail: err.Error()}
			return out, err
		}
		// Recompute installment at capped rate to keep consistent with schedule (in case cap applied)
		targetInstallment, err = pEng.CalculateInstallment(input.Deal.FinancedAmount, targetRate, input.Deal.TermMonths, input.Deal.BalloonAmount)
		if err != nil {
			out.Error = &types.CampaignError{Code: "invalid_inputs", Summary: "Cannot calc installment at rate", Detail: err.Error()}
			return out, err
		}
	}

	// Compute required subsidy from PV difference
	pvTarget := pvOfSchedule(targetSched, targetRate)
	required := pvBase.Sub(pvTarget)
	if required.LessThan(decimal.Zero) {
		required = required.Abs() // defensive
	}
	required = types.RoundTHB(required)

	// Budget handling
	used := required
	overBudget := false
	exceed := decimal.Zero
	if input.BudgetTHB != nil && input.BudgetTHB.GreaterThanOrEqual(decimal.Zero) {
		if required.GreaterThan(*input.BudgetTHB) {
			overBudget = true
			exceed = types.RoundTHB(required.Sub(*input.BudgetTHB))
			used = types.RoundTHB(*input.BudgetTHB)
			out.Diagnostics["exceeded_budget_manual_override"] = "required subsidy exceeds provided budget; clipped used to budget"
		}
	}

	// Build cashflows and profitability using "used" subsidy at T0
	t0 := []types.Cashflow{{
		Date:      input.Deal.PayoutDate,
		Direction: "in",
		Type:      types.CashflowSubsidy,
		Amount:    used,
		Memo:      "Subinterest subsidy (manual target)",
	}}
	t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
	allCF := cfEng.MergeCashflows(t0, targetSched)
	dealIRR, _ := cfEng.CalculateDealIRR(t0, targetSched, nil)
	wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

	out.Metrics = types.CampaignMetrics{
		CustomerNominalRate:         types.RoundBasisPoints(targetRate),
		CustomerEffectiveRate:       pEng.CalculateEffectiveRate(targetRate, 12),
		MonthlyInstallment:          targetInstallment,
		SubsidyUsedTHB:              used,
		RequiredSubsidyTHB:          required,
		ExceedTHB:                   exceed,
		OverBudget:                  overBudget,
		DealerCommissionResolvedTHB: decimal.Zero,
		DealerCommissionPctResolved: decimal.Zero,
		IDCTotalTHB:                 decimal.Zero,
		AcquisitionRoRAC:            wf.AcquisitionRoRAC,
		NetEBITMargin:               wf.NetEBITMargin,
		EconomicCapital:             wf.EconomicCapital,
	}
	out.Schedule = targetSched
	out.Cashflows = allCF
	out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
	return out, nil
}

// MARK: helpers

func resolveBasePricing(pEng *pricing.Engine, deal types.Deal) (nominalRate decimal.Decimal, schedule []types.Cashflow, installment decimal.Decimal, err error) {
	switch deal.RateMode {
	case "fixed_rate":
		nominalRate = deal.CustomerNominalRate
		schedule, err = pEng.BuildAmortizationSchedule(deal, nominalRate)
		if err != nil {
			return
		}
		installment, err = pEng.CalculateInstallment(deal.FinancedAmount, nominalRate, deal.TermMonths, deal.BalloonAmount)
		return
	case "target_installment":
		installment = deal.TargetInstallment
		nominalRate, err = pEng.SolveForRate(deal.FinancedAmount, installment, deal.TermMonths, deal.BalloonAmount)
		if err != nil {
			return
		}
		schedule, err = pEng.BuildAmortizationSchedule(deal, nominalRate)
		return
	default:
		err = fmt.Errorf("unsupported RateMode: %s", deal.RateMode)
		return
	}
}

func pvOfSchedule(schedule []types.Cashflow, nominalRate decimal.Decimal) decimal.Decimal {
	if len(schedule) == 0 {
		return decimal.Zero
	}
	monthly := nominalRate.Div(decimal.NewFromInt(12))
	onePlus := decimal.NewFromInt(1).Add(monthly)
	pv := decimal.Zero
	period := 0
	for _, cf := range schedule {
		// Consider periodic inflows only (principal installments and balloon)
		if cf.Direction != "in" {
			continue
		}
		if cf.Type != types.CashflowPrincipal && cf.Type != types.CashflowBalloon {
			continue
		}
		period++
		// Discount factor = (1 + r_m)^period
		df := decimal.NewFromFloat(math.Pow(onePlus.InexactFloat64(), float64(period)))
		if df.IsZero() {
			continue
		}
		pv = pv.Add(cf.Amount.Div(df))
	}
	return pv
}

func solveRateForBudget(pEng *pricing.Engine, deal types.Deal, pvBase decimal.Decimal, budget decimal.Decimal, lo decimal.Decimal, hi decimal.Decimal) (rate decimal.Decimal, usedSubsidy decimal.Decimal, sched []types.Cashflow, installment decimal.Decimal, err error) {
	const maxIter = 100
	pvTol := decimal.NewFromFloat(0.01)
	rTol := decimal.NewFromFloat(0.0001) // 1 bp

	// Objective f(r) = PV_base - PV_target(r) - Budget
	f := func(r decimal.Decimal) (decimal.Decimal, []types.Cashflow) {
		s, _ := pEng.BuildAmortizationSchedule(deal, r)
		pvT := pvOfSchedule(s, r)
		diff := pvBase.Sub(pvT).Sub(budget)
		return diff, s
	}

	// Check bounds
	fLo, sLo := f(lo)
	// Ensure root is bracketed: fLo >= 0 and fHi <= 0 for positive budget; we handled clip case earlier.
	if fLo.LessThan(decimal.Zero) {
		// Should have been clipped before; return lo best-effort
		rate = lo
		usedSubsidy = pvBase.Sub(pvOfSchedule(sLo, lo))
		sched = sLo
		installment, _ = pEng.CalculateInstallment(deal.FinancedAmount, rate, deal.TermMonths, deal.BalloonAmount)
		err = fmt.Errorf("root not bracketed (f(lo)<0); clip expected")
		return
	}

	var mid, bestR decimal.Decimal
	bestR = lo
	bestAbs := fLo.Abs()

	for i := 0; i < maxIter; i++ {
		mid = lo.Add(hi).Div(decimal.NewFromInt(2))
		fMid, sMid := f(mid)
		absMid := fMid.Abs()
		// Track best
		if absMid.LessThan(bestAbs) {
			bestAbs = absMid
			bestR = mid
			sched = sMid
		}

		// Convergence checks
		if absMid.LessThanOrEqual(pvTol) || hi.Sub(lo).Abs().LessThanOrEqual(rTol) {
			rate = types.RoundBasisPoints(mid)
			installment, _ = pEng.CalculateInstallment(deal.FinancedAmount, rate, deal.TermMonths, deal.BalloonAmount)
			usedSubsidy = pvBase.Sub(pvOfSchedule(sMid, rate))
			return
		}

		// Bisection: decide side by sign
		if fMid.GreaterThan(decimal.Zero) {
			// Need smaller difference -> move toward hi (higher rate)
			lo = mid
		} else {
			hi = mid
		}
	}

	// Fallback to bestR after max iterations
	if sched == nil {
		// recompute for bestR if not set
		_, sched = f(bestR)
	}
	rate = types.RoundBasisPoints(bestR)
	installment, _ = pEng.CalculateInstallment(deal.FinancedAmount, rate, deal.TermMonths, deal.BalloonAmount)
	usedSubsidy = pvBase.Sub(pvOfSchedule(sched, rate))
	err = fmt.Errorf("bisection max iterations reached")
	return
}

func finalizeBudgetResult(
	input types.CampaignBudgetInput,
	out types.CampaignResult,
	rate decimal.Decimal,
	schedule []types.Cashflow,
	installment decimal.Decimal,
	used decimal.Decimal,
	exceed decimal.Decimal,
	diag string,
	pEng *pricing.Engine,
	cfEng *cashflow.Engine,
	prof *profitability.Engine,
) (types.CampaignResult, error) {
	t0 := []types.Cashflow{}
	if used.GreaterThan(decimal.Zero) {
		t0 = append(t0, types.Cashflow{
			Date:      input.Deal.PayoutDate,
			Direction: "in",
			Type:      types.CashflowSubsidy,
			Amount:    used,
			Memo:      "Subinterest subsidy",
		})
	}
	t0 = cfEng.ConstructT0Flows(input.Deal, t0, nil)
	allCF := cfEng.MergeCashflows(t0, schedule)
	dealIRR, _ := cfEng.CalculateDealIRR(t0, schedule, nil)
	wf, _ := prof.CalculateWaterfall(input.Deal, dealIRR, decimal.Zero, decimal.Zero)

	out.Metrics = types.CampaignMetrics{
		CustomerNominalRate:         types.RoundBasisPoints(rate),
		CustomerEffectiveRate:       pEng.CalculateEffectiveRate(rate, 12),
		MonthlyInstallment:          installment,
		SubsidyUsedTHB:              types.RoundTHB(used),
		RequiredSubsidyTHB:          types.RoundTHB(used),
		ExceedTHB:                   types.RoundTHB(exceed),
		OverBudget:                  false,
		DealerCommissionResolvedTHB: decimal.Zero,
		DealerCommissionPctResolved: decimal.Zero,
		IDCTotalTHB:                 decimal.Zero,
		AcquisitionRoRAC:            wf.AcquisitionRoRAC,
		NetEBITMargin:               wf.NetEBITMargin,
		EconomicCapital:             wf.EconomicCapital,
	}
	out.Schedule = schedule
	out.Cashflows = allCF
	if diag != "" {
		if out.Diagnostics == nil {
			out.Diagnostics = map[string]string{}
		}
		out.Diagnostics[diag] = "no rate movement"
	}
	if out.Diagnostics == nil {
		out.Diagnostics = map[string]string{}
	}
	out.Diagnostics["dealer_commission_unresolved"] = "commission policy not wired in subinterest solver; defaulted to 0"
	return out, nil
}
